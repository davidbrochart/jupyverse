{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Jupyverse is a FastAPI -based Jupyter server. It can be used to run JupyterLab and other web clients in different scenarios: On your personal machine: that's the most common use case, where you want to do interactive computing, most often running notebooks, in your local environment. Although JupyterLab runs in the browser, it really feels like a desktop application. Collaboratively: users work on the same document in real time, connected to the same server. That means they are on the same private network (LAN), or the server is hosted on the Internet. The user experience is similar to Google Docs. With access control: this becomes necessary when working collaboratively, as you don't want everybody to be able to see or change any thing. You want to know who users are and give them more or less permissions.","title":"Overview"},{"location":"install/","text":"Jupyverse can be installed to run either JupyterLab or RetroLab . With pip For the JupyterLab front-end: pip install \"jupyverse[jupyterlab,auth]\" Or for the RetroLab front-end: pip install \"jupyverse[retrolab,auth]\" With mamba For the JupyterLab front-end: mamba install -c conda-forge jupyverse fps-jupyterlab fps-auth Or for the RetroLab front-end: mamba install -c conda-forge jupyverse fps-retrolab fps-auth Note You cannot have both the JupyterLab and the RetroLab front-ends enabled at the same time. When switching e.g. from the JupyterLab to the RetroLab front-end, you need to pip uninstall fps-jupyterlab or launch Jupyverse with --jupyterlab.enabled=false . More on that in the plugins section . Development install You first need to clone the repository: git clone https://github.com/jupyter-server/jupyverse.git cd jupyverse Jupyverse uses Hatch for project management, hatch can handle multiple environments in parallel allowing for easy development and testing of different frontends, authentication methods, and incompatible plugins. First you should install Hatch , once it is installed you can run hatch env show to view the available environments. This will show a table like: Standalone \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Name \u2503 Type \u2503 Features \u2503 Scripts \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 default \u2502 virtual \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 docs \u2502 virtual \u2502 docs \u2502 build \u2502 \u2502 \u2502 \u2502 \u2502 serve \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Matrices \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Name \u2503 Type \u2503 Envs \u2503 Features \u2503 Dependencies \u2503 Scripts \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 dev \u2502 virtual \u2502 dev.jupyterlab-noauth \u2502 test \u2502 fastapi>=0.82.0 \u2502 jupyverse \u2502 \u2502 \u2502 \u2502 dev.jupyterlab-auth \u2502 \u2502 \u2502 lint \u2502 \u2502 \u2502 \u2502 dev.jupyterlab-auth_fief \u2502 \u2502 \u2502 test \u2502 \u2502 \u2502 \u2502 dev.retrolab-noauth \u2502 \u2502 \u2502 typecheck \u2502 \u2502 \u2502 \u2502 dev.retrolab-auth \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 dev.retrolab-auth_fief \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 The default environment will install all the plugins from pypi, not from the plugin directory, as this is what users get when they install jupyverse. The dev environment installs all plugins in editable mode from the plugin directory. Currently the dev matrix environment is made up of all combinations of frontends ( jupyterlab , retrolab ) and authentication methods ( noauth , auth , auth_fief ), which leads to six combinations. A number of scripts are available in the dev environments, scripts can be executed using hatch run {env}:{script} , e.g. to serve jupyverse from the jupyterlab noauth environment use hatch run dev.jupyterlab-noauth:jupyverse . Tests should normally be executed using the dev.jupyterlab-auth environment, e.g. hatch run dev.jupyterlab-auth:test . You can also use the -e flag to set an environment, which work with other commands like shell, so hatch -e dev.jupyterlab-noauth shell will spawn a shell with that environment activated, which is useful for interactive testing and development. As the plugins are all installed in editable mode, you could start an instance of jupyverse in each environment and see how code changes interact with plugins at the same time. Finally, hatch run docs:serve can be used to view documentation changes.","title":"Install"},{"location":"install/#with-pip","text":"For the JupyterLab front-end: pip install \"jupyverse[jupyterlab,auth]\" Or for the RetroLab front-end: pip install \"jupyverse[retrolab,auth]\"","title":"With pip"},{"location":"install/#with-mamba","text":"For the JupyterLab front-end: mamba install -c conda-forge jupyverse fps-jupyterlab fps-auth Or for the RetroLab front-end: mamba install -c conda-forge jupyverse fps-retrolab fps-auth Note You cannot have both the JupyterLab and the RetroLab front-ends enabled at the same time. When switching e.g. from the JupyterLab to the RetroLab front-end, you need to pip uninstall fps-jupyterlab or launch Jupyverse with --jupyterlab.enabled=false . More on that in the plugins section .","title":"With mamba"},{"location":"install/#development-install","text":"You first need to clone the repository: git clone https://github.com/jupyter-server/jupyverse.git cd jupyverse Jupyverse uses Hatch for project management, hatch can handle multiple environments in parallel allowing for easy development and testing of different frontends, authentication methods, and incompatible plugins. First you should install Hatch , once it is installed you can run hatch env show to view the available environments. This will show a table like: Standalone \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Name \u2503 Type \u2503 Features \u2503 Scripts \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 default \u2502 virtual \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 docs \u2502 virtual \u2502 docs \u2502 build \u2502 \u2502 \u2502 \u2502 \u2502 serve \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Matrices \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Name \u2503 Type \u2503 Envs \u2503 Features \u2503 Dependencies \u2503 Scripts \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 dev \u2502 virtual \u2502 dev.jupyterlab-noauth \u2502 test \u2502 fastapi>=0.82.0 \u2502 jupyverse \u2502 \u2502 \u2502 \u2502 dev.jupyterlab-auth \u2502 \u2502 \u2502 lint \u2502 \u2502 \u2502 \u2502 dev.jupyterlab-auth_fief \u2502 \u2502 \u2502 test \u2502 \u2502 \u2502 \u2502 dev.retrolab-noauth \u2502 \u2502 \u2502 typecheck \u2502 \u2502 \u2502 \u2502 dev.retrolab-auth \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 dev.retrolab-auth_fief \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 The default environment will install all the plugins from pypi, not from the plugin directory, as this is what users get when they install jupyverse. The dev environment installs all plugins in editable mode from the plugin directory. Currently the dev matrix environment is made up of all combinations of frontends ( jupyterlab , retrolab ) and authentication methods ( noauth , auth , auth_fief ), which leads to six combinations. A number of scripts are available in the dev environments, scripts can be executed using hatch run {env}:{script} , e.g. to serve jupyverse from the jupyterlab noauth environment use hatch run dev.jupyterlab-noauth:jupyverse . Tests should normally be executed using the dev.jupyterlab-auth environment, e.g. hatch run dev.jupyterlab-auth:test . You can also use the -e flag to set an environment, which work with other commands like shell, so hatch -e dev.jupyterlab-noauth shell will spawn a shell with that environment activated, which is useful for interactive testing and development. As the plugins are all installed in editable mode, you could start an instance of jupyverse in each environment and see how code changes interact with plugins at the same time. Finally, hatch run docs:serve can be used to view documentation changes.","title":"Development install"},{"location":"plugins/auth/","text":"The auth plugin has a special place because every other plugin depends on it for security reasons. One and only one auth plugin must be installed. It is possible to use any auth plugin as long as it follows a defined API . Jupyverse comes with three auth plugins: fps-noauth , fps-auth and fps-auth-fief . API An auth plugin must register the following objects in the jupyverse_auth entry point group: User : a Pydantic model for a user. It must have at least the following fields: class User ( BaseModel ): username : str = \"\" name : str = \"\" display_name : str = \"\" initials : Optional [ str ] = None color : Optional [ str ] = None avatar_url : Optional [ str ] = None workspace : str = \" {} \" settings : str = \" {} \" current_user : a callable that optionally takes in required permissions for the HTTP endpoint, and returns a FastAPI dependency for the currently logged in user after checking that they have permissions. The user must have all the required permissions (if any), otherwise a 403 HTTP code is returned. def current_user ( permissions : Optional [ Dict [ str , List [ str ]]] = None ): async def _current_user (): if user_has_permissions ( permissions ): return User ( ** { \"username\" : \"John\" }) raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN ) return _current_user websocket_auth : a callable that optionally takes in required permissions for the WebSocket endpoint, and returns a FastAPI dependency for a tuple consisting of the WebSocket object and the checked permissions, if the WebSocket is accepted, or None if the WebSocket is refused. If the WebSocket is refused, the dependency has to close it, otherwise it has to be accepted by the caller. The user must have at least one of the required permissions (if any) for the WebSocket to be accepted. def websocket_auth ( permissions : Optional [ Dict [ str , List [ str ]]] = None ): async def _websocket_auth ( websocket : WebSocket ) -> Optional [ Tuple [ WebSocket , Optional [ Dict [ str , List [ str ]]]]]: accept_websocket = False checked_permissions : Optional [ Dict [ str , List [ str ]]] = None if SESSION_COOKIE_NAME in websocket . _cookies : access_token = websocket . _cookies [ SESSION_COOKIE_NAME ] if permissions is None : accept_websocket = True else : checked_permissions = {} for resource , actions in permissions . items (): allowed = checked_permissions [ resource ] = [] for action in actions : if user_has_permission ( resource , action ): allowed . append ( action ) accept_websocket = True if accept_websocket : return websocket , checked_permissions else : await websocket . close ( code = status . WS_1008_POLICY_VIOLATION ) return None return _websocket_auth update_user : a FastAPI dependency for a coroutine that takes in user data to update. async def update_user (): async def _update_user ( data : Dict [ str , Any ]): await update_user_profile ( data ) return _update_user fps-noauth fps-noauth \"implements\" an unprotected API. Note This can be a security risk! Use it only if you want all endpoints to be accessible by any user. fps-auth fps-auth is a FastAPI-Users -based solution that includes auth endpoints (registration, etc.) inside Jupyverse, as well as the user database. It is thus perfect if you want Jupyverse to completely \"embed\" authentication. fps-auth-fief fps-auth-fief is a Fief -based solution that runs separately from Jupyverse. It can be hosted in the cloud or locally.","title":"auth"},{"location":"plugins/auth/#api","text":"An auth plugin must register the following objects in the jupyverse_auth entry point group: User : a Pydantic model for a user. It must have at least the following fields: class User ( BaseModel ): username : str = \"\" name : str = \"\" display_name : str = \"\" initials : Optional [ str ] = None color : Optional [ str ] = None avatar_url : Optional [ str ] = None workspace : str = \" {} \" settings : str = \" {} \" current_user : a callable that optionally takes in required permissions for the HTTP endpoint, and returns a FastAPI dependency for the currently logged in user after checking that they have permissions. The user must have all the required permissions (if any), otherwise a 403 HTTP code is returned. def current_user ( permissions : Optional [ Dict [ str , List [ str ]]] = None ): async def _current_user (): if user_has_permissions ( permissions ): return User ( ** { \"username\" : \"John\" }) raise HTTPException ( status_code = status . HTTP_403_FORBIDDEN ) return _current_user websocket_auth : a callable that optionally takes in required permissions for the WebSocket endpoint, and returns a FastAPI dependency for a tuple consisting of the WebSocket object and the checked permissions, if the WebSocket is accepted, or None if the WebSocket is refused. If the WebSocket is refused, the dependency has to close it, otherwise it has to be accepted by the caller. The user must have at least one of the required permissions (if any) for the WebSocket to be accepted. def websocket_auth ( permissions : Optional [ Dict [ str , List [ str ]]] = None ): async def _websocket_auth ( websocket : WebSocket ) -> Optional [ Tuple [ WebSocket , Optional [ Dict [ str , List [ str ]]]]]: accept_websocket = False checked_permissions : Optional [ Dict [ str , List [ str ]]] = None if SESSION_COOKIE_NAME in websocket . _cookies : access_token = websocket . _cookies [ SESSION_COOKIE_NAME ] if permissions is None : accept_websocket = True else : checked_permissions = {} for resource , actions in permissions . items (): allowed = checked_permissions [ resource ] = [] for action in actions : if user_has_permission ( resource , action ): allowed . append ( action ) accept_websocket = True if accept_websocket : return websocket , checked_permissions else : await websocket . close ( code = status . WS_1008_POLICY_VIOLATION ) return None return _websocket_auth update_user : a FastAPI dependency for a coroutine that takes in user data to update. async def update_user (): async def _update_user ( data : Dict [ str , Any ]): await update_user_profile ( data ) return _update_user","title":"API"},{"location":"plugins/auth/#fps-noauth","text":"fps-noauth \"implements\" an unprotected API. Note This can be a security risk! Use it only if you want all endpoints to be accessible by any user.","title":"fps-noauth"},{"location":"plugins/auth/#fps-auth","text":"fps-auth is a FastAPI-Users -based solution that includes auth endpoints (registration, etc.) inside Jupyverse, as well as the user database. It is thus perfect if you want Jupyverse to completely \"embed\" authentication.","title":"fps-auth"},{"location":"plugins/auth/#fps-auth-fief","text":"fps-auth-fief is a Fief -based solution that runs separately from Jupyverse. It can be hosted in the cloud or locally.","title":"fps-auth-fief"},{"location":"plugins/contents/","text":"fps-contents implements the contents API, i.e. everything related to reading/writing files, for the local file system. It also provides notifications for file changes using watchfiles .","title":"fps-contents"},{"location":"plugins/fps/","text":"FPS is the system used in Jupyverse to extend its functionality. Actually, Jupyverse is just a collection of FPS plugins that together implement a Jupyter server. In Jupyverse, each plugin is quite independant, except that they all depend on the auth plugin. This is because almost every endpoint has to be protected one way or another. Jupyverse extensions You can extend Jupyverse by creating an FPS plugin. FPS plugins can have configuration and router endpoints that must be registered in entry point groups fps_config and fps_router , respectively. In a setup.cfg file, that would look like the following: [options.entry_points] fps_config = fps-myextension = fps_myextension.config fps_router = fps-myextension = fps_myextension.routes Where fps-myextension is the name of your plugin (the fps- prefix will automatically be striped). The configuration will live in fps_myextension/config.py , and will look like: from fps.config import PluginModel from fps.hooks import register_config class MyConfig ( PluginModel ): my_param1 : str = \"\" my_param2 : int = 0 c = register_config ( MyConfig ) The router will live in fps_myextension/routes.py , and will look like: from fastapi import APIRouter from fps.hooks import register_router router = APIRouter () @router . get ( \"/myendpoint\" ) def read_endpoint (): return { \"Hello\" : \"World\" } r = register_router ( router ) That's it! You just need to install this Python package and it will automatically be discovered by FPS at run-time. The /myendpoint endpoint will be added to Jupyverse, and you can configure your plugin e.g. at the CLI with: jupyverse --myextension.my_param2 = 3","title":"FPS"},{"location":"plugins/fps/#jupyverse-extensions","text":"You can extend Jupyverse by creating an FPS plugin. FPS plugins can have configuration and router endpoints that must be registered in entry point groups fps_config and fps_router , respectively. In a setup.cfg file, that would look like the following: [options.entry_points] fps_config = fps-myextension = fps_myextension.config fps_router = fps-myextension = fps_myextension.routes Where fps-myextension is the name of your plugin (the fps- prefix will automatically be striped). The configuration will live in fps_myextension/config.py , and will look like: from fps.config import PluginModel from fps.hooks import register_config class MyConfig ( PluginModel ): my_param1 : str = \"\" my_param2 : int = 0 c = register_config ( MyConfig ) The router will live in fps_myextension/routes.py , and will look like: from fastapi import APIRouter from fps.hooks import register_router router = APIRouter () @router . get ( \"/myendpoint\" ) def read_endpoint (): return { \"Hello\" : \"World\" } r = register_router ( router ) That's it! You just need to install this Python package and it will automatically be discovered by FPS at run-time. The /myendpoint endpoint will be added to Jupyverse, and you can configure your plugin e.g. at the CLI with: jupyverse --myextension.my_param2 = 3","title":"Jupyverse extensions"},{"location":"plugins/frontend/","text":"fps-frontend implements the common frontend configuration.","title":"fps-frontend"},{"location":"plugins/jupyterlab/","text":"fps-jupyterlab implements the JupyterLab API.","title":"fps-jupyterlab"},{"location":"plugins/kernels/","text":"fps-kernels implements the kernels API, i.e. launching and stopping kernels, serving the kernel protocol over WebSocket, etc.","title":"fps-kernels"},{"location":"plugins/lab/","text":"fps-lab implements everything that is common to JupyterLab and RetroLab.","title":"fps-lab"},{"location":"plugins/login/","text":"fps-login implements the login page for fps-auth 's token authentication.","title":"fps-login"},{"location":"plugins/nbconvert/","text":"fps-nbconvert implements the API for exporting notebooks to various formats.","title":"fps-nbconvert"},{"location":"plugins/retrolab/","text":"fps-retrolab implements the RetroLab API.","title":"fps-retrolab"},{"location":"plugins/terminals/","text":"fps-terminals implements the terminals API, i.e. opening, closing and interacting with terminals.","title":"fps-terminals"},{"location":"plugins/yjs/","text":"fps-yjs implements the Yjs API, i.e. everything related to collaborative editing.","title":"fps-yjs"},{"location":"usage/multi_user/","text":"Jupyverse supports multiple users working collaboratively. Depending on the chosen authentication method, access to the server can be finer-grained. For instance, it is possible to require users to create an account before they can log in, and to give them permissions restricting access to specific resources. It is also possible to let them log in as anonymous users. The authentication method largely depends on the level of security you want. Collaborative editing The first thing to do is to allow collaborative editing when launching Jupyverse: jupyverse --lab.collaborative The collaborative mode will handle users through the auth plugin you have installed, which will provide user identity. Identity provider The real power of collaborative editing comes with proper user authentication and authorization. Jupyverse comes with several \"auth plugins\", that will be described below, but you can implement your own. It just has to follow a defined API . Using fps-auth Token or no authentication It can be enabled by launching: jupyverse --lab.collaborative --auth.mode = token This uses the token authentication, the same as described in the single user mode . This means that users don't get a \"real\" identity, since all they provide is the shared token. For this reason, we call them \"anonymous users\". They can still be differenciated, and they will each get assigned a different name e.g. in JupyterLab, but they will all have full access to any resource. For instance, they will be able to open all documents and to execute any code. You can also disable token authentication in collaborative mode, just as in single user mode : jupyverse --lab.collaborative --auth.mode = noauth User authentication It can be enabled by launching: jupyverse --lab.collaborative --auth.mode = user In this mode, users have to be registered in a database before logging in. User information includes a user name and a password, that will be asked at login. It can also include a \"real\" name, that will be displayed when editing documents, and permissions that will determine if they can see or edit a document, run some code, etc. Using fps-auth-fief fps-auth-fief uses Fief to authenticate users. Fief itself can be hosted in the cloud or locally, but in any case it runs a separate server, and implements OAuth2 to access Jupyverse. Fief allows to manage users using a dashboard. It supports permissions and Role-Based Access Control (RBAC). Just launch in a terminal: jupyverse --lab.collaborative","title":"Multi user"},{"location":"usage/multi_user/#collaborative-editing","text":"The first thing to do is to allow collaborative editing when launching Jupyverse: jupyverse --lab.collaborative The collaborative mode will handle users through the auth plugin you have installed, which will provide user identity.","title":"Collaborative editing"},{"location":"usage/multi_user/#identity-provider","text":"The real power of collaborative editing comes with proper user authentication and authorization. Jupyverse comes with several \"auth plugins\", that will be described below, but you can implement your own. It just has to follow a defined API .","title":"Identity provider"},{"location":"usage/multi_user/#using-fps-auth","text":"","title":"Using fps-auth"},{"location":"usage/multi_user/#token-or-no-authentication","text":"It can be enabled by launching: jupyverse --lab.collaborative --auth.mode = token This uses the token authentication, the same as described in the single user mode . This means that users don't get a \"real\" identity, since all they provide is the shared token. For this reason, we call them \"anonymous users\". They can still be differenciated, and they will each get assigned a different name e.g. in JupyterLab, but they will all have full access to any resource. For instance, they will be able to open all documents and to execute any code. You can also disable token authentication in collaborative mode, just as in single user mode : jupyverse --lab.collaborative --auth.mode = noauth","title":"Token or no authentication"},{"location":"usage/multi_user/#user-authentication","text":"It can be enabled by launching: jupyverse --lab.collaborative --auth.mode = user In this mode, users have to be registered in a database before logging in. User information includes a user name and a password, that will be asked at login. It can also include a \"real\" name, that will be displayed when editing documents, and permissions that will determine if they can see or edit a document, run some code, etc.","title":"User authentication"},{"location":"usage/multi_user/#using-fps-auth-fief","text":"fps-auth-fief uses Fief to authenticate users. Fief itself can be hosted in the cloud or locally, but in any case it runs a separate server, and implements OAuth2 to access Jupyverse. Fief allows to manage users using a dashboard. It supports permissions and Role-Based Access Control (RBAC). Just launch in a terminal: jupyverse --lab.collaborative","title":"Using fps-auth-fief"},{"location":"usage/single_user/","text":"The single user mode is usually meant to run e.g. JupyterLab as a desktop application. Under the hood, a server and a web front-end are launched, but it should be transparent to the user, who just interacts with a \"web app\". Even though Jupyverse most often runs on a personal computer in this mode, it is not limited to this use case. For instance, if it runs on a network, it could be accessed by other people. It is thus important to limit access to the server, especially considering that Jupyter users can run potentially harmful code. This is why Jupyverse comes with built-in authentication. Please refer to the auth plugins section for more details. The authentication mechanisms below make use of the fps-auth plugin. Token authentication This is the default mode when launching Jupyverse, just enter in a terminal: jupyverse # same as: jupyverse --auth.mode=token This should open a new window in a browser, and load JupyterLab or RetroLab, depending on the front-end you chose to install (see Install ). If you look at the terminal, you should see among other things: [I 2022-08-30 09:37:55 auth] To access the server, copy and paste this URL: [I 2022-08-30 09:37:55 auth] http://127.0.0.1:8000/?token=59665677-06c6-4530-ab67-d26cd8865d8b This is the URL the browser window was opened with, and you can see that a token was passed as a query parameter. When the request is made to the server, the token is checked and a cookie is set in the browser. The user is now authenticated and doesn't need to pass the token again in other requests. Other users trying to access the server will be redirected to a login page. They can enter the token there, or completely bypass this step if they paste the above URL. Sharing the token is the responsibility of the user who launched Jupyverse. This simple mechanism effectively prevents access to the server by unkown users. No authentication If you trust everybody who can access the server, you can launch Jupyverse with no authentication whatsoever. It can also be convenient if you run Jupyverse on your personal computer and want to open e.g. JupyterLab in multiple browsers (e.g. Firefox and Google Chrome), since they don't share cookies. This way you won't need to pass any token in the URL. Enter in a terminal: jupyverse --auth.mode = noauth","title":"Single user"},{"location":"usage/single_user/#token-authentication","text":"This is the default mode when launching Jupyverse, just enter in a terminal: jupyverse # same as: jupyverse --auth.mode=token This should open a new window in a browser, and load JupyterLab or RetroLab, depending on the front-end you chose to install (see Install ). If you look at the terminal, you should see among other things: [I 2022-08-30 09:37:55 auth] To access the server, copy and paste this URL: [I 2022-08-30 09:37:55 auth] http://127.0.0.1:8000/?token=59665677-06c6-4530-ab67-d26cd8865d8b This is the URL the browser window was opened with, and you can see that a token was passed as a query parameter. When the request is made to the server, the token is checked and a cookie is set in the browser. The user is now authenticated and doesn't need to pass the token again in other requests. Other users trying to access the server will be redirected to a login page. They can enter the token there, or completely bypass this step if they paste the above URL. Sharing the token is the responsibility of the user who launched Jupyverse. This simple mechanism effectively prevents access to the server by unkown users.","title":"Token authentication"},{"location":"usage/single_user/#no-authentication","text":"If you trust everybody who can access the server, you can launch Jupyverse with no authentication whatsoever. It can also be convenient if you run Jupyverse on your personal computer and want to open e.g. JupyterLab in multiple browsers (e.g. Firefox and Google Chrome), since they don't share cookies. This way you won't need to pass any token in the URL. Enter in a terminal: jupyverse --auth.mode = noauth","title":"No authentication"}]}