{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Jupyverse is a FastAPI-based Jupyter server. It can be used to run JupyterLab and other web clients in different scenarios:</p> <ul> <li>On your personal machine: that's the most common use case, where you want to do interactive computing, most often running notebooks, in your local environment. Although JupyterLab runs in the browser, it really feels like a desktop application.</li> <li>Collaboratively: users work on the same document in real time, connected to the same server. That means they are on the same private network (LAN), or the server is hosted on the Internet. The user experience is similar to Google Docs.</li> <li>With access control: this becomes necessary when working collaboratively, as you don't want everybody to be able to see or change any thing. You want to know who users are and give them more or less permissions.</li> </ul>"},{"location":"install/","title":"Install","text":"<p>Jupyverse can be installed to run either JupyterLab or RetroLab.</p>"},{"location":"install/#with-pip","title":"With <code>pip</code>","text":"<p>For the JupyterLab frontend: <pre><code>pip install \"jupyverse[jupyterlab,auth]\"\n</code></pre> Or for the RetroLab frontend: <pre><code>pip install \"jupyverse[retrolab,auth]\"\n</code></pre></p>"},{"location":"install/#with-micromamba","title":"With <code>micromamba</code>","text":"<p>We recommend using <code>micromamba</code> to manage conda-forge environments (see <code>micromamba</code>'s installation instructions). First create an environment, here called <code>jupyverse</code>, and activate it: <pre><code>micromamba create -n jupyverse\nmicromamba activate jupyverse\n</code></pre> Then install Jupyverse and the desired plugins.</p> <p>For the JupyterLab frontend: <pre><code>micromamba install -c conda-forge jupyverse fps-jupyterlab fps-auth\n</code></pre> Or for the RetroLab frontend: <pre><code>micromamba install -c conda-forge jupyverse fps-retrolab fps-auth\n</code></pre></p>"},{"location":"install/#development-install","title":"Development install","text":"<p>You first need to clone the repository: <pre><code>git clone https://github.com/jupyter-server/jupyverse.git\ncd jupyverse\n</code></pre> Jupyverse uses Hatch for project management. Hatch can handle multiple environments in parallel, allowing for easy development and testing of different frontends, authentication methods, and incompatible plugins.</p> <p>We recommend working in an isolated conda environment, in which hatch will manage sub-environments: <pre><code>micromamba create -n jupyverse-dev\nmicromamba activate jupyverse-dev\nmicromamba install -c conda-forge hatch\n</code></pre> Entering <code>hatch env show</code> will show the available environments: <pre><code>                Standalone\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Name    \u2503 Type    \u2503 Features \u2503 Scripts \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 default \u2502 virtual \u2502          \u2502         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 docs    \u2502 virtual \u2502 docs     \u2502 build   \u2502\n\u2502         \u2502         \u2502          \u2502 serve   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              Matrices\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Name \u2503 Type    \u2503 Envs                     \u2503 Features \u2503 Scripts   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 dev  \u2502 virtual \u2502 dev.jupyterlab-noauth    \u2502 test     \u2502 lint      \u2502\n\u2502      \u2502         \u2502 dev.jupyterlab-auth      \u2502          \u2502 test      \u2502\n\u2502      \u2502         \u2502 dev.jupyterlab-auth_fief \u2502          \u2502 typecheck \u2502\n\u2502      \u2502         \u2502 dev.retrolab-noauth      \u2502          \u2502           \u2502\n\u2502      \u2502         \u2502 dev.retrolab-auth        \u2502          \u2502           \u2502\n\u2502      \u2502         \u2502 dev.retrolab-auth_fief   \u2502          \u2502           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>Note</p> <p>The <code>default</code> environment will install all the plugins from PyPI, not from your local repository. The <code>dev</code> environment installs all plugins in editable mode from your local repository. So you want to use the <code>dev</code> environment.</p> <p>Currently, the <code>dev</code> environment matrix consists of all combinations of frontends (<code>jupyterlab</code>, <code>retrolab</code>) and authentication methods (<code>noauth</code>, <code>auth</code>, <code>auth_fief</code>), which leads to six environments.</p> <p>A number of scripts are available in the <code>dev</code> environments. They can be executed using <code>hatch run {env}:{script}</code>. You can also execute anything that you would execute in your shell. For instance, to run Jupyverse for the <code>jupyterlab</code> frontend and without authentication, enter: <pre><code>hatch run dev.jupyterlab-noauth:jupyverse\n</code></pre></p> <p>Tests should be executed using the <code>dev.jupyterlab-auth</code> environment: <pre><code>hatch run dev.jupyterlab-auth:test\n</code></pre> Sometimes it is easier to directly be in the environment, without having to prefix everything with <code>hatch run {env}:</code>. To do so, just enter: <pre><code>hatch -e dev.jupyterlab-auth shell\n</code></pre> You can now directly enter shell commands, e.g. <code>jupyverse</code>. To exit the environment, just enter <code>exit</code>.</p> <p>As the plugins are all installed in editable mode, you could start an instance of Jupyverse in each environment and see how code changes interact with plugins at the same time.</p> <p>Finally, <code>hatch run docs:serve</code> can be used to view documentation changes.</p> <p>If you ever need to start from a fresh environment, you can remove them individually: <pre><code>hatch env remove dev.jupyterlab-auth\n</code></pre> Or globally: <pre><code>hatch env prune\n</code></pre></p>"},{"location":"plugins/auth/","title":"auth","text":"<p>The auth plugin has a special place because almost every other plugin depends on it for security reasons. It is possible to use any auth plugin as long as it follows a defined API. Jupyverse comes with three auth plugins: fps-noauth, fps-auth and fps-auth-fief.</p>"},{"location":"plugins/auth/#api","title":"API","text":"<p>An auth plugin must implement a class that inherits from the <code>jupyverse_api.Auth</code> abstract base class. This class must have the following methods:</p> <ul> <li><code>current_user</code>: a method that optionally takes in required permissions for the HTTP endpoint, and returns a FastAPI dependency for the currently logged in user after checking that they have permissions. The user must have all the required permissions (if any), otherwise a <code>403</code> HTTP code is returned. <pre><code>def current_user(self, permissions: Optional[Dict[str, List[str]]] = None) -&gt; Callable:\n    async def _current_user():\n        if user_has_permissions(permissions):\n            return User(**{\"username\": \"John\"})\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN)\n\n    return _current_user\n</code></pre></li> <li><code>websocket_auth</code>: a method that optionally takes in required permissions for the WebSocket endpoint, and returns a FastAPI dependency for a tuple consisting of the WebSocket object and the checked permissions, if the WebSocket is accepted, or <code>None</code> if the WebSocket is refused. If the WebSocket is refused, the dependency has to close the connection, otherwise it has to be accepted by the caller. The user must have at least one of the required permissions (if any) for the WebSocket to be accepted. <pre><code>def websocket_auth(self, permissions: Optional[Dict[str, List[str]]] = None) -&gt; Callable[[], Optional[Tuple[Any, Dict[str, List[str]]]]]:\n    async def _websocket_auth(websocket: WebSocket) -&gt; Optional[Tuple[WebSocket, Optional[Dict[str, List[str]]]]]:\n        accept_websocket = False\n        checked_permissions: Optional[Dict[str, List[str]]] = None\n        if SESSION_COOKIE_NAME in websocket._cookies:\n            access_token = websocket._cookies[SESSION_COOKIE_NAME]\n            if permissions is None:\n                accept_websocket = True\n            else:\n                checked_permissions = {}\n                for resource, actions in permissions.items():\n                    allowed = checked_permissions[resource] = []\n                    for action in actions:\n                        if user_has_permission(resource, action):\n                            allowed.append(action)\n                            accept_websocket = True\n        if accept_websocket:\n            return websocket, checked_permissions\n        else:\n            await websocket.close(code=status.WS_1008_POLICY_VIOLATION)\n            return None\n\n    return _websocket_auth\n</code></pre></li> <li><code>update_user</code>: a FastAPI dependency for a coroutine that takes in user data to update. <pre><code>async def update_user(self) -&gt; Callable:\n    async def _update_user(data: Dict[str, Any]):\n        await update_user_profile(data)\n\n    return _update_user\n</code></pre></li> </ul>"},{"location":"plugins/auth/#fps-noauth","title":"fps-noauth","text":"<p><code>fps-noauth</code> \"implements\" an unprotected API.</p> <p>Note</p> <p>This can be a security risk! Use it only if you want all endpoints to be accessible by any user. Typically, only do that on your personal computer.</p>"},{"location":"plugins/auth/#fps-auth","title":"fps-auth","text":"<p><code>fps-auth</code> is a FastAPI-Users-based solution that includes auth endpoints (registration, etc.) inside Jupyverse, as well as the user database. It is thus perfect if you want Jupyverse to completely \"embed\" authentication.</p>"},{"location":"plugins/auth/#fps-auth-fief","title":"fps-auth-fief","text":"<p><code>fps-auth-fief</code> is a Fief-based solution that runs separately from Jupyverse. It can be hosted in the cloud or locally.</p>"},{"location":"plugins/contents/","title":"contents","text":"<p><code>fps-contents</code> implements the <code>contents</code> API, i.e. everything related to reading/writing files, for the local file system. It also provides notifications for file changes using watchfiles.</p>"},{"location":"plugins/frontend/","title":"frontend","text":"<p><code>fps-frontend</code> implements the common frontend configuration.</p>"},{"location":"plugins/jupyterlab/","title":"jupyterlab","text":"<p><code>fps-jupyterlab</code> implements the JupyterLab API.</p>"},{"location":"plugins/kernels/","title":"kernels","text":"<p><code>fps-kernels</code> implements the kernels API, i.e. launching and stopping kernels, serving the kernel protocol over WebSocket, etc.</p>"},{"location":"plugins/lab/","title":"lab","text":"<p><code>fps-lab</code> implements everything that is common to JupyterLab and RetroLab.</p>"},{"location":"plugins/login/","title":"login","text":"<p><code>fps-login</code> implements the login page for fps-auth's token authentication.</p>"},{"location":"plugins/nbconvert/","title":"nbconvert","text":"<p><code>fps-nbconvert</code> implements the API for exporting notebooks to various formats.</p>"},{"location":"plugins/resource_usage/","title":"resource-usage","text":"<p><code>fps-resource-usage</code> implements the resource usage API, for monitoring memory and CPU usage.</p>"},{"location":"plugins/retrolab/","title":"retrolab","text":"<p><code>fps-retrolab</code> implements the RetroLab API.</p>"},{"location":"plugins/terminals/","title":"terminals","text":"<p><code>fps-terminals</code> implements the terminals API, i.e. opening, closing and interacting with terminals.</p>"},{"location":"plugins/yjs/","title":"yjs","text":"<p><code>fps-yjs</code> implements the Yjs API, i.e. everything related to collaborative editing.</p>"},{"location":"usage/microservices/","title":"Microservices","text":"<p>Jupyverse's modularity allows to run services quite independently from each other, following a microservice architecture. This can be useful when resources are provided by separate systems, or just to have a clear separation of concerns. For instance, you may want to host the contents on AWS and the kernels on Google Cloud, or on different machines in your private network. One way to achieve this is to use a reverse proxy that will forward client requests to the corresponding Jupyverse server. We will show how to do that using Nginx on a single computer with local servers. This can serve as a basis for more complicated architectures involving remote servers.</p>"},{"location":"usage/microservices/#nginx-setup","title":"Nginx setup","text":"<p>Nginx is a web server that can also be used as a reverse proxy. We will use it to forward client requests to separate Jupyverse servers, based on the request URL.</p> <p>First, install Nginx in its own environment: <pre><code>micromamba create -n nginx\nmicromamba activate nginx\nmicromamba install -c conda-forge nginx\n</code></pre> We will just edit the default configuration file at <code>~/micromamba/envs/nginx/etc/nginx/sites.d/default-site.conf</code> with the following: <pre><code>server {\n    listen       8000;\n    server_name  localhost;\n\n    location / {\n        proxy_pass http://localhost:8001;\n    }\n\n    location /api/kernelspecs {\n        proxy_pass http://localhost:8002;\n    }\n    location /api/kernels {\n        proxy_pass http://localhost:8002;\n    }\n    location ~ \\/api\\/kernels\\/.+\\/channels {\n        proxy_pass http://localhost:8002;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"Upgrade\";\n    }\n    location /api/sessions {\n        proxy_pass http://localhost:8002;\n    }\n}\n</code></pre> Our Nginx server will listen at <code>http://localhost:8000</code>. This is the URL the client will see, i.e. the one we enter in the browser.</p> <p>Our Jupyverse servers will run on:</p> <ul> <li><code>http://localhost:8001</code> for everything except the kernels API. This means that this server doesn't have the ability to run user code, and thus cannot be used to execute a notebook.</li> <li><code>http://localhost:8002</code> for the kernels API. This server only deals with executing code in a kernel. It cannot serve JupyterLab's UI, for instance.</li> </ul> <p>Together, these Jupyverse servers can serve a full JupyterLab API. But because they run on different machines (not exactly in this case, since ports <code>8001</code> and <code>8002</code> are on the same machine, but let's pretend), we need to make them appear as a unique server. That is the role of the reverse proxy server.</p> <p>Note</p> <p>WebSocket forwarding requires extra-configuration. Here, we use a <code>regex</code> to redirect <code>/api/kernels/{kernel_id}/channels</code>, which is the WebSocket endpoint for the kernel protocol. We also set the <code>Upgrade</code> and <code>Connection</code> headers used to upgrade the connection from HTTP to WebSocket.</p> <p>We can now run our reverse proxy server. Just enter: <pre><code>nginx\n</code></pre></p>"},{"location":"usage/microservices/#jupyverse-setup","title":"Jupyverse setup","text":""},{"location":"usage/microservices/#server-1-everything-but-kernels","title":"Server 1: everything but kernels","text":"<p>Let's create a new environment in a new terminal: <pre><code>micromamba create -n jupyverse1\nmicromamba activate jupyverse1\nmicromamba install -c conda-forge python\n</code></pre> Since we don't want to install the fully-fledged Jupyverse server, we will install the required plugins individually: <pre><code>pip install fps-auth\npip install fps-contents\npip install fps-frontend\npip install fps-lab\npip install fps-jupyterlab\npip install fps-login\n</code></pre> Now we launch Jupyverse at port <code>8001</code> and pass our own authentication token. In production, you would either create your own token, or let Jupyverse create it, and copy/paste it for server 2. <pre><code>jupyverse --port=8001 --set auth.token=5e9b01f993bc4fb48b2bf6958fd22981\n</code></pre> If you open your browser at <code>http://127.0.0.1:8000</code> (the URL of the Nginx reverse proxy), you should see the JupyterLab UI you're used to. But if you look closer, you can see that there is no icon for kernels in the launcher tab. And in the terminal where you launched Jupyverse, you will see a bunch of <code>404</code> for requests at e.g. <code>GET /api/kernels</code>. This is expected, because we didn't install the kernels plugin. You can still use JupyterLab if you don't want to execute a notebook, for instance. But let's close it for now, and install the kernels plugin in another Jupyverse instance.</p>"},{"location":"usage/microservices/#server-2-the-kernels-api","title":"Server 2: the kernels API","text":"<p>Let's create a new environment in a new terminal: <pre><code>micromamba create -n jupyverse2\nmicromamba activate jupyverse2\nmicromamba install -c conda-forge python\n</code></pre> This time, we only want to install the kernels plugin. Let's not forget to install a kernel, such as <code>ipykernel</code>: <pre><code>pip install fps-kernels\npip install fps-auth\npip install fps-frontend\npip install ipykernel\n</code></pre> Launch Juyverse at port <code>8002</code> with the same authentication token as for server 1: <pre><code>jupyverse --port=8002 --set auth.token=5e9b01f993bc4fb48b2bf6958fd22981\n</code></pre> Now if you re-open a browser at <code>http://127.0.0.1:8000</code>, you should be able to create or open a notebook, and execute it.</p>"},{"location":"usage/multi_user/","title":"Multi user","text":"<p>Jupyverse supports multiple users working collaboratively. Depending on the chosen authentication method, access to the server can be finer-grained. For instance, it is possible to require users to create an account before they can log in, and to give them permissions restricting access to specific resources. It is also possible to let them log in as anonymous users. The authentication method largely depends on the level of security you want.</p>"},{"location":"usage/multi_user/#collaborative-editing","title":"Collaborative editing","text":"<p>The first thing to do is to allow collaborative editing when launching Jupyverse: <pre><code>jupyverse --set frontend.collaborative=true\n</code></pre> The collaborative mode will handle users through the auth plugin you have installed, which will provide user identity.</p>"},{"location":"usage/multi_user/#identity-provider","title":"Identity provider","text":"<p>The real power of collaborative editing comes with proper user authentication and authorization. Jupyverse comes with several \"auth plugins\", that will be described below, but you can implement your own. It just has to follow a defined API.</p>"},{"location":"usage/multi_user/#using-fps-auth","title":"Using fps-auth","text":""},{"location":"usage/multi_user/#token-or-no-authentication","title":"Token or no authentication","text":"<p>It can be enabled by launching: <pre><code>jupyverse --set frontend.collaborative=true --set auth.mode=token\n</code></pre> This uses the token authentication, the same as described in the single user mode. This means that users don't get a \"real\" identity, since all they provide is the shared token. For this reason, we call them \"anonymous users\".</p> <p>They can still be differenciated, and they will each get assigned a different name e.g. in JupyterLab, but they will all have full access to any resource. For instance, they will be able to open all documents and to execute any code.</p> <p>You can also disable token authentication in collaborative mode, just as in single user mode: <pre><code>jupyverse --set frontend.collaborative=true --set auth.mode=noauth\n</code></pre></p>"},{"location":"usage/multi_user/#user-authentication","title":"User authentication","text":"<p>It can be enabled by launching: <pre><code>jupyverse --set frontend.collaborative=true --set auth.mode=user\n</code></pre> In this mode, users have to be registered in a database before logging in. User information includes a user name and a password, that will be asked at login. It can also include a \"real\" name, that will be displayed when editing documents, and permissions that will determine if they can see or edit a document, run some code, etc.</p>"},{"location":"usage/multi_user/#using-fps-auth-fief","title":"Using fps-auth-fief","text":"<p>fps-auth-fief uses Fief to authenticate users. Fief itself can be hosted in the cloud or locally, but in any case it runs a separate server, and implements OAuth2 to access Jupyverse.</p> <p>Fief allows to manage users using a dashboard. It supports permissions and Role-Based Access Control (RBAC).</p> <p>Just launch in a terminal: <pre><code>jupyverse --set frontend.collaborative=true\n</code></pre></p>"},{"location":"usage/single_user/","title":"Single user","text":"<p>The single user mode is usually meant to run e.g. JupyterLab as a desktop application. Under the hood, a server and a web frontend are launched, but it should be transparent to the user, who just interacts with a \"web app\".</p> <p>Even though Jupyverse most often runs on a personal computer in this mode, it is not limited to this use case. For instance, if it runs on a network, it could be accessed by other people. It is thus important to limit access to the server, especially considering that Jupyter users can run potentially harmful code.</p> <p>This is why Jupyverse comes with built-in authentication. Please refer to the auth plugins section for more details. The authentication mechanisms below make use of the fps-auth plugin.</p>"},{"location":"usage/single_user/#token-authentication","title":"Token authentication","text":"<p>This is the default mode when launching Jupyverse, just enter in a terminal: <pre><code>jupyverse --open-browser\n# same as: jupyverse --set auth.mode=token --open-browser\n</code></pre> This should open a new window in a browser, and load JupyterLab or RetroLab, depending on the front-end you chose to install (see Install).</p> <p>If you look at the terminal, you should see among other things: <pre><code>[2023-04-05 16:22:39,137 INFO] To access the server, copy and paste this URL:\n[2023-04-05 16:22:39,137 INFO] http://127.0.0.1:8000/?token=69ce8ccee10d4388b00b3df0d9849700\n</code></pre> This is the URL the browser window was opened with, and you can see that a <code>token</code> was passed as a query parameter. When the request is made to the server, the token is checked and a cookie is set in the browser. The user is now authenticated and doesn't need to pass the token again in other requests.</p> <p>Other users trying to access the server will be redirected to a login page. They can enter the token there, or completely bypass this step if they paste the above URL. Sharing the token is the responsibility of the user who launched Jupyverse. This simple mechanism effectively prevents access to the server by unkown users.</p>"},{"location":"usage/single_user/#no-authentication","title":"No authentication","text":"<p>If you trust everybody who can access the server, you can launch Jupyverse with no authentication whatsoever. It can also be convenient if you run Jupyverse on your personal computer and want to open e.g. JupyterLab in multiple browsers (e.g. Firefox and Google Chrome), since they don't share cookies. This way you won't need to pass any token in the URL.</p> <p>Enter in a terminal: <pre><code>jupyverse --set auth.mode=noauth --open-browser\n</code></pre></p>"}]}