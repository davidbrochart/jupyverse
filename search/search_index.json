{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Jupyverse is a FastAPI-based Jupyter server. It can be used to run JupyterLab and other web clients in different scenarios:</p> <ul> <li>On your personal machine: that's the most common use case, where you want to do interactive computing, most often running notebooks, in your local environment. Although JupyterLab runs in the browser, it really feels like a desktop application.</li> <li>Collaboratively: users work on the same document in real time, connected to the same server. That means they are on the same private network (LAN), or the server is hosted on the Internet. The user experience is similar to Google Docs.</li> <li>With access control: this becomes necessary when working collaboratively, as you don't want everybody to be able to see or change any thing. You want to know who users are and give them more or less permissions.</li> </ul>"},{"location":"install/","title":"Install","text":"<p>Jupyverse can be installed to run either JupyterLab or RetroLab.</p>"},{"location":"install/#with-pip","title":"With <code>pip</code>","text":"<p>For the JupyterLab frontend: <pre><code>pip install \"jupyverse[jupyterlab,auth]\"\n</code></pre> Or for the RetroLab frontend: <pre><code>pip install \"jupyverse[retrolab,auth]\"\n</code></pre></p>"},{"location":"install/#with-micromamba","title":"With <code>micromamba</code>","text":"<p>We recommend using <code>micromamba</code> to manage conda-forge environments (see <code>micromamba</code>'s installation instructions). First create an environment, here called <code>jupyverse</code>, and activate it: <pre><code>micromamba create -n jupyverse\nmicromamba activate jupyverse\n</code></pre> Then install Jupyverse and the desired plugins.</p> <p>For the JupyterLab frontend: <pre><code>micromamba install -c conda-forge jupyverse fps-jupyterlab fps-auth\n</code></pre> Or for the RetroLab frontend: <pre><code>micromamba install -c conda-forge jupyverse fps-retrolab fps-auth\n</code></pre></p>"},{"location":"install/#development-install","title":"Development install","text":"<p>You first need to clone the repository: <pre><code>git clone https://github.com/jupyter-server/jupyverse.git\ncd jupyverse\n</code></pre> Jupyverse uses Hatch for project management. Hatch can handle multiple environments in parallel, allowing for easy development and testing of different frontends, authentication methods, and incompatible plugins.</p> <p>We recommend working in an isolated conda environment, in which hatch will manage sub-environments: <pre><code>micromamba create -n jupyverse-dev\nmicromamba activate jupyverse-dev\nmicromamba install -c conda-forge hatch\n</code></pre> Entering <code>hatch env show</code> will show the available environments: <pre><code>                Standalone\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Name    \u2503 Type    \u2503 Features \u2503 Scripts \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 default \u2502 virtual \u2502          \u2502         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 docs    \u2502 virtual \u2502 docs     \u2502 build   \u2502\n\u2502         \u2502         \u2502          \u2502 serve   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                              Matrices\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Name \u2503 Type    \u2503 Envs                     \u2503 Features \u2503 Scripts   \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 dev  \u2502 virtual \u2502 dev.jupyterlab-noauth    \u2502 test     \u2502 lint      \u2502\n\u2502      \u2502         \u2502 dev.jupyterlab-auth      \u2502          \u2502 test      \u2502\n\u2502      \u2502         \u2502 dev.jupyterlab-auth_fief \u2502          \u2502 typecheck \u2502\n\u2502      \u2502         \u2502 dev.retrolab-noauth      \u2502          \u2502           \u2502\n\u2502      \u2502         \u2502 dev.retrolab-auth        \u2502          \u2502           \u2502\n\u2502      \u2502         \u2502 dev.retrolab-auth_fief   \u2502          \u2502           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p> <p>Note</p> <p>The <code>default</code> environment will install all the plugins from PyPI, not from your local repository. The <code>dev</code> environment installs all plugins in editable mode from your local repository. So you want to use the <code>dev</code> environment.</p> <p>Currently, the <code>dev</code> environment matrix consists of all combinations of frontends (<code>jupyterlab</code>, <code>retrolab</code>) and authentication methods (<code>noauth</code>, <code>auth</code>, <code>auth_fief</code>), which leads to six environments.</p> <p>A number of scripts are available in the <code>dev</code> environments. They can be executed using <code>hatch run {env}:{script}</code>. You can also execute anything that you would execute in your shell. For instance, to run Jupyverse for the <code>jupyterlab</code> frontend and without authentication, enter: <pre><code>hatch run dev.jupyterlab-noauth:jupyverse\n</code></pre></p> <p>Tests should be executed using the <code>dev.jupyterlab-auth</code> environment: <pre><code>hatch run dev.jupyterlab-auth:test\n</code></pre> Sometimes it is easier to directly be in the environment, without having to prefix everything with <code>hatch run {env}:</code>. To do so, just enter: <pre><code>hatch -e dev.jupyterlab-auth shell\n</code></pre> You can now directly enter shell commands, e.g. <code>jupyverse</code>. To exit the environment, just enter <code>exit</code>.</p> <p>As the plugins are all installed in editable mode, you could start an instance of Jupyverse in each environment and see how code changes interact with plugins at the same time.</p> <p>Finally, <code>hatch run docs:serve</code> can be used to view documentation changes.</p> <p>If you ever need to start from a fresh environment, you can remove them individually: <pre><code>hatch env remove dev.jupyterlab-auth\n</code></pre> Or globally: <pre><code>hatch env prune\n</code></pre></p>"},{"location":"plugins/auth/","title":"auth","text":"<p>The auth plugin has a special place because almost every other plugin depends on it for security reasons. It is possible to use any auth plugin as long as it follows a defined API. Jupyverse comes with three auth plugins: fps-noauth, fps-auth and fps-auth-fief.</p>"},{"location":"plugins/auth/#api","title":"API","text":"<p>An auth plugin must implement a class that inherits from the <code>jupyverse_api.Auth</code> abstract base class. This class must have the following methods:</p> <ul> <li><code>current_user</code>: a method that optionally takes in required permissions for the HTTP endpoint, and returns a FastAPI dependency for the currently logged in user after checking that they have permissions. The user must have all the required permissions (if any), otherwise a <code>403</code> HTTP code is returned. <pre><code>def current_user(self, permissions: Optional[Dict[str, List[str]]] = None) -&gt; Callable:\n    async def _current_user():\n        if user_has_permissions(permissions):\n            return User(**{\"username\": \"John\"})\n        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN)\n\n    return _current_user\n</code></pre></li> <li><code>websocket_auth</code>: a method that optionally takes in required permissions for the WebSocket endpoint, and returns a FastAPI dependency for a tuple consisting of the WebSocket object and the checked permissions, if the WebSocket is accepted, or <code>None</code> if the WebSocket is refused. If the WebSocket is refused, the dependency has to close the connection, otherwise it has to be accepted by the caller. The user must have at least one of the required permissions (if any) for the WebSocket to be accepted. <pre><code>def websocket_auth(self, permissions: Optional[Dict[str, List[str]]] = None) -&gt; Callable[[], Optional[Tuple[Any, Dict[str, List[str]]]]]:\n    async def _websocket_auth(websocket: WebSocket) -&gt; Optional[Tuple[WebSocket, Optional[Dict[str, List[str]]]]]:\n        accept_websocket = False\n        checked_permissions: Optional[Dict[str, List[str]]] = None\n        if SESSION_COOKIE_NAME in websocket._cookies:\n            access_token = websocket._cookies[SESSION_COOKIE_NAME]\n            if permissions is None:\n                accept_websocket = True\n            else:\n                checked_permissions = {}\n                for resource, actions in permissions.items():\n                    allowed = checked_permissions[resource] = []\n                    for action in actions:\n                        if user_has_permission(resource, action):\n                            allowed.append(action)\n                            accept_websocket = True\n        if accept_websocket:\n            return websocket, checked_permissions\n        else:\n            await websocket.close(code=status.WS_1008_POLICY_VIOLATION)\n            return None\n\n    return _websocket_auth\n</code></pre></li> <li><code>update_user</code>: a FastAPI dependency for a coroutine that takes in user data to update. <pre><code>async def update_user(self) -&gt; Callable:\n    async def _update_user(data: Dict[str, Any]):\n        await update_user_profile(data)\n\n    return _update_user\n</code></pre></li> </ul>"},{"location":"plugins/auth/#fps-noauth","title":"fps-noauth","text":"<p><code>fps-noauth</code> \"implements\" an unprotected API.</p> <p>Note</p> <p>This can be a security risk! Use it only if you want all endpoints to be accessible by any user. Typically, only do that on your personal computer.</p>"},{"location":"plugins/auth/#fps-auth","title":"fps-auth","text":"<p><code>fps-auth</code> is a FastAPI-Users-based solution that includes auth endpoints (registration, etc.) inside Jupyverse, as well as the user database. It is thus perfect if you want Jupyverse to completely \"embed\" authentication.</p>"},{"location":"plugins/auth/#fps-auth-fief","title":"fps-auth-fief","text":"<p><code>fps-auth-fief</code> is a Fief-based solution that runs separately from Jupyverse. It can be hosted in the cloud or locally.</p>"},{"location":"plugins/contents/","title":"contents","text":"<p><code>fps-contents</code> implements the <code>contents</code> API, i.e. everything related to reading/writing files, for the local file system. It also provides notifications for file changes using watchfiles.</p>"},{"location":"plugins/frontend/","title":"frontend","text":"<p><code>fps-frontend</code> implements the common frontend configuration.</p>"},{"location":"plugins/jupyterlab/","title":"jupyterlab","text":"<p><code>fps-jupyterlab</code> implements the JupyterLab API.</p>"},{"location":"plugins/kernels/","title":"kernels","text":"<p><code>fps-kernels</code> implements the kernels API, i.e. launching and stopping kernels, serving the kernel protocol over WebSocket, etc.</p>"},{"location":"plugins/lab/","title":"lab","text":"<p><code>fps-lab</code> implements everything that is common to JupyterLab and RetroLab.</p>"},{"location":"plugins/login/","title":"login","text":"<p><code>fps-login</code> implements the login page for fps-auth's token authentication.</p>"},{"location":"plugins/nbconvert/","title":"nbconvert","text":"<p><code>fps-nbconvert</code> implements the API for exporting notebooks to various formats.</p>"},{"location":"plugins/resource_usage/","title":"resource-usage","text":"<p><code>fps-resource-usage</code> implements the resource usage API, for monitoring memory and CPU usage.</p>"},{"location":"plugins/retrolab/","title":"retrolab","text":"<p><code>fps-retrolab</code> implements the RetroLab API.</p>"},{"location":"plugins/terminals/","title":"terminals","text":"<p><code>fps-terminals</code> implements the terminals API, i.e. opening, closing and interacting with terminals.</p>"},{"location":"plugins/yjs/","title":"yjs","text":"<p><code>fps-yjs</code> implements the Yjs API, i.e. everything related to collaborative editing.</p>"},{"location":"tutorials/deployment/","title":"Deployment","text":"<p>In this tutorial, we will deploy Jupyverse on a public OVHcloud instance using Fief, and allow authentication using a GitHub account.</p>"},{"location":"tutorials/deployment/#ovh-setup","title":"OVH setup","text":""},{"location":"tutorials/deployment/#create-and-connect-to-a-public-instance","title":"Create and connect to a public instance","text":"<p>Let's follow the guide on Creating and connecting to your first Public Cloud instance. We first need to create SSH keys, so that we can connect to our instance using SSH. Enter in a terminal:</p> <pre><code>$ ssh-keygen -b 4096\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/user/.ssh/id_rsa):\n</code></pre> <p>You can hit Enter. You are then asked to enter a passphrase, we will need it later.</p> <p>The public key can be accessed with:</p> <pre><code>$ cat ~/.ssh/id_rsa.pub\n</code></pre> <p>Copy this public key into your clipboard.</p> <p>In the OVHcloud Control Panel, click on \"Instances\" and then \"Create an instance\". Choose the \"B2-7\" model, which is a light and general use instance, and click \"Next\".</p> <p>Select a region of you choice and click \"Next\".</p> <p>Select the \"Ubuntu 23.04\" image and click \"Add a key\" under \"SSH key\". Give it a name an paste your public key, then click \"Next\". Your instance should already be configured, you can click \"Next\" again. In the network configuration, make sure \"Public mode\" is checked, and click \"Next\". Then select your preferred billing period and click \"Create an instance\".</p> <p>Your instance should activate shortly. You can see it has a public IP, something like <code>1.2.3.4</code>. Let's connect to the instance using this IP address:</p> <p><pre><code>$ ssh ubuntu@1.2.3.4\nThe authenticity of host '1.2.3.4 (1.2.3.4)' can't be established.\nED25519 key fingerprint is SHA256:Q1&amp;tbgX3fp9+7J90zyK0ctuKe1aqPoEY76Qi58uoSnA.\nThis key is not known by any other names\nAre you sure you want to continue connecting (yes/no/[fingerprint])?\n</code></pre> Enter \"yes\", then enter your passphrase. You should now be connected to your instance.</p>"},{"location":"tutorials/deployment/#set-up-the-environment","title":"Set up the environment","text":"<p>Let's install micromamba and configure it:</p> <pre><code>$ sudo apt install bzip2\n$ curl -Ls https://micro.mamba.pm/api/micromamba/linux-64/latest | tar -xvj bin/micromamba\n$ bin/micromamba shell init --shell bash --root-prefix=~/micromamba\n$ exec bash\n</code></pre> <p>Now create a conda environment and install Python:</p> <pre><code>$ micromamba create -n jupyverse\n$ micromamba activate jupyverse\n$ micromamba install -c conda-forge python\n</code></pre> <p>And install Jupyverse:</p> <pre><code>$ pip install jupyverse[jupyterlab,auth-fief] jupyter-collaboration\n</code></pre>"},{"location":"tutorials/deployment/#set-up-https-and-nginx","title":"Set up HTTPS and NGINX","text":"<p>For this you will need a domain name, like https://my.jupyverse.com, that must point to your instance through its IP address.</p> <p>We'll use NGINX and Let's Encrypt to manage SSL/TLS certificates. Enter in a terminal:</p> <pre><code>$ sudo apt install certbot nginx python3-certbot-nginx\n</code></pre> <p>Create a file at <code>/etc/nginx/conf.d/my.jupyverse.com.conf</code> (note that <code>my.jupyverse.com</code> is your domain name) with the following content:</p> <pre><code>server {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n    root /var/www/html;\n    server_name my.jupyverse.com;\n}\n</code></pre> <p>Save the file, then run this command to verify the syntax of your configuration and restart NGINX:</p> <pre><code>$ sudo nginx -t &amp;&amp; sudo nginx -s reload\n</code></pre> <p>You may have to remove the server section in /etc/nginx/sites-enabled/default, or simply remove this file. Now run the following command to generate certificates with the NGINX plug\u2011in:</p> <pre><code>$ sudo certbot --nginx -d my.jupyverse.com\n</code></pre> <p>After answering a few questions, you should be all set. If you look at <code>/etc/nginx/conf.d/my.jupyverse.com.conf</code> again, you should see that it was modified. Add the following <code>location</code> sections at the bottom:</p> <pre><code>server {\n    root /var/www/html;\n    server_name my.jupyverse.com;\n\n    listen [::]:443 ssl ipv6only=on; # managed by Certbot\n    listen 443 ssl; # managed by Certbot\n    ssl_certificate /etc/letsencrypt/live/my.jupyverse.com/fullchain.pem; # managed by Certbot\n    ssl_certificate_key /etc/letsencrypt/live/my.jupyverse.com/privkey.pem; # managed by Certbot\n    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot\n    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot\n\n    location / {\n        proxy_pass http://localhost:8000;\n    }\n    location ~ \\/api\\/kernels\\/.+\\/channels {\n        proxy_pass http://localhost:8000;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"Upgrade\";\n    }\n    location ~ \\/terminals\\/websocket\\/.+ {\n        proxy_pass http://localhost:8000;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"Upgrade\";\n    }\n    location ~ \\/api\\/collaboration\\/room\\/.+ {\n        proxy_pass http://localhost:8000;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"Upgrade\";\n    }\n\n}\n</code></pre>"},{"location":"tutorials/deployment/#fief-setup","title":"Fief setup","text":"<p>You will first need to create a Fief account. At the time of writing, you can join the beta for free.</p> <p>Then, create a workspace. Let's call it \"jupyverse\".</p> <p>You will be asked where to store your data. Let's choose Fief's cloud database.</p> <p>Now that your workspace is created, we need to configure our tenant. There can be multiple tenants per workspace, but a default tenant was created with the same name as your workspace, so we'll use this one. Since we want to allow GitHub authentication, we first need to create a corresponding OAuth provider.</p> <p>Click on \"OAuth Providers\" on the left, and then \"create OAuth Provider\" on the right. Choose GitHub in the provider list. You can see that we need to provide a client ID and secret. In order to get those, we need to register a new GitHub App. Leave this window open, we'll get back to it later.</p> <p>You can go through the steps given by Fief to create a GitHub App. In the \"GitHub App name\", enter \"Jupyverse\". In \"Homepage URL\", enter the URL of your public instance, https://my.jupyverse.com. In \"Callback URL\", enter https://jupyverse.fief.dev/oauth/callback. Make sure \"Expire user authorization tokens\" and \"Request user authorization (OAuth) during installation\" are checked. Uncheck \"Active\" for \"Webhook\". In \"Account permissions\", give \"Read-only\" access to \"Email addresses\". Finally, hit the \"Create GitHub App\" button at the bottom.</p> <p>If this was successful, you can now generate a private key. Click on \"Generate a new client secret\", and copy it somewhere safe. Let's also copy the client ID shown on the same page. Now let's go back to the Fief browser window where we were creating our GitHub OAuth provider, and enter the client ID and Secret, and hit \"Create\" (also remove any scope if present).</p> <p>Let's click on \"Tenants\" on the left, and then on our \"jupyverse\" tenant, then \"Edit tenant\" on the right. We want registration to be allowed, and it should be checked by default. In \"OAuth Providers\", choose \"GitHub\" and click \"Update\".</p> <p>Click on \"Clients\" on the left. A client was already created, click on it and then click on \"Edit Client\" on the right. We need to change the \"Redirect URIs\", so let's delete the existing one and click on \"Add\", then enter https://my.jupyverse.com/auth-callback, and click \"Update\".</p> <p>Now let's click on \"API Keys\" on the left, then \"Create API Key\" on the right. Name it and click \"Create\". This should give you a key, copy it somewhere safe.</p> <p>We need to create user fields. Click on \"User fields\" on the left, then \"Create User field\" on the right. Enter each of the following fields. The name is automatically copied into Slug, the \"String\" type is chosen by default. Enter a default value if any, and check \"Ask at profile update\":</p> Name Default value <code>workspace</code> <code>{}</code> <code>settings</code> <code>{}</code> <code>username</code> <code>name</code> <code>display_name</code> <code>initials</code> <code>color</code> <code>avatar_url</code> <p>We also need to create permissions. Click on \"Access control\" on the left, then \"Permissions\". Enter each of the following value pairs into \"Name\" and \"Codename\" respectively, click \"Create Permission\" on the right.</p> Name Codename <code>Read contents</code> <code>contents:read</code> <code>Read kernelspecs</code> <code>kernelspecs:read</code> <code>Read kernels</code> <code>kernels:read</code> <code>Read sessions</code> <code>sessions:read</code> <code>Read terminals</code> <code>terminals:read</code> <code>Read yjs</code> <code>yjs:read</code> <code>Write contents</code> <code>contents:write</code> <code>Write kernels</code> <code>kernels:write</code> <code>Write sessions</code> <code>sessions:write</code> <code>Write terminals</code> <code>terminals:write</code> <code>Write yjs</code> <code>yjs:write</code> <code>Execute kernels</code> <code>kernels:execute</code> <code>Execute terminals</code> <code>terminals:execute</code>"},{"location":"tutorials/deployment/#run-the-server","title":"Run the server","text":"<p>We are ready to run Jupyverse. Let's do it in a separate directory, replacing in the following command:</p> <ul> <li><code>fief_client_id</code> with our Fief client ID,</li> <li><code>fief_client_secret</code> with our Fief client secret,</li> <li><code>fief_admin_api</code> with our API key,</li> <li><code>fief_oauth_provider_id</code> with our GitHub OAuth provider ID.</li> </ul> <pre><code>$ mkdir jupyverse &amp;&amp; cd jupyverse\n$ jupyverse \\\n--set auth_fief.base_url=https://jupyverse.fief.dev \\\n--set auth_fief.client_id=fief_client_id \\\n--set auth_fief.client_secret=fief_client_secret \\\n--set auth_fief.admin_api_key=fief_admin_api \\\n--set auth_fief.oauth_provider_id=fief_oauth_provider_id \\\n--set auth_fief.callback_url=https://my.jupyverse.com/auth-callback\n</code></pre> <p>Now open a browser window at https://my.jupyverse.com, and click \"Sign in with GitHub\". Enter your credentials and click \"Sign in\". If you have two-factor authentication enabled on your GitHub account, you may have to approve the request by entering a code e.g. in your mobile phone GitHub application. You should be redirected back to Fief, where you are asked to provide an email to finalize the sign up. It should be pre-filled with your GitHub email. Just click \"Finalize sign up\".</p> <p>After a while, JupyterLab should start. You should see your avatar in the top-left corner. Any other connected user should be visible in the \"Collaboration\" tab on the left, and if you work on the same notebook, you should see them collaborate live!</p>"},{"location":"usage/microservices/","title":"Microservices","text":"<p>Jupyverse's modularity allows to run services quite independently from each other, following a microservice architecture. This can be useful when resources are provided by separate systems, or just to have a clear separation of concerns. For instance, you may want to host the contents on AWS and the kernels on Google Cloud, or on different machines in your private network. One way to achieve this is to use a reverse proxy that will forward client requests to the corresponding Jupyverse server. We will show how to do that using Nginx on a single computer with local servers. This can serve as a basis for more complicated architectures involving remote servers.</p>"},{"location":"usage/microservices/#nginx-setup","title":"Nginx setup","text":"<p>Nginx is a web server that can also be used as a reverse proxy. We will use it to forward client requests to separate Jupyverse servers, based on the request URL.</p> <p>First, install Nginx in its own environment: <pre><code>micromamba create -n nginx\nmicromamba activate nginx\nmicromamba install -c conda-forge nginx\n</code></pre> We will just edit the default configuration file at <code>~/micromamba/envs/nginx/etc/nginx/sites.d/default-site.conf</code> with the following: <pre><code>server {\n    listen       8000;\n    server_name  localhost;\n\n    location / {\n        proxy_pass http://localhost:8001;\n    }\n\n    location /api/kernelspecs {\n        proxy_pass http://localhost:8002;\n    }\n    location /api/kernels {\n        proxy_pass http://localhost:8002;\n    }\n    location ~ \\/api\\/kernels\\/.+\\/channels {\n        proxy_pass http://localhost:8002;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection \"Upgrade\";\n    }\n    location /api/sessions {\n        proxy_pass http://localhost:8002;\n    }\n}\n</code></pre> Our Nginx server will listen at <code>http://localhost:8000</code>. This is the URL the client will see, i.e. the one we enter in the browser.</p> <p>Our Jupyverse servers will run on:</p> <ul> <li><code>http://localhost:8001</code> for everything except the kernels API. This means that this server doesn't have the ability to run user code, and thus cannot be used to execute a notebook.</li> <li><code>http://localhost:8002</code> for the kernels API. This server only deals with executing code in a kernel. It cannot serve JupyterLab's UI, for instance.</li> </ul> <p>Together, these Jupyverse servers can serve a full JupyterLab API. But because they run on different machines (not exactly in this case, since ports <code>8001</code> and <code>8002</code> are on the same machine, but let's pretend), we need to make them appear as a unique server. That is the role of the reverse proxy server.</p> <p>Note</p> <p>WebSocket forwarding requires extra-configuration. Here, we use a <code>regex</code> to redirect <code>/api/kernels/{kernel_id}/channels</code>, which is the WebSocket endpoint for the kernel protocol. We also set the <code>Upgrade</code> and <code>Connection</code> headers used to upgrade the connection from HTTP to WebSocket.</p> <p>We can now run our reverse proxy server. Just enter: <pre><code>nginx\n</code></pre></p>"},{"location":"usage/microservices/#jupyverse-setup","title":"Jupyverse setup","text":""},{"location":"usage/microservices/#server-1-everything-but-kernels","title":"Server 1: everything but kernels","text":"<p>Let's create a new environment in a new terminal: <pre><code>micromamba create -n jupyverse1\nmicromamba activate jupyverse1\nmicromamba install -c conda-forge python\n</code></pre> Since we don't want to install the fully-fledged Jupyverse server, we will install the required plugins individually: <pre><code>pip install fps-auth\npip install fps-contents\npip install fps-frontend\npip install fps-lab\npip install fps-jupyterlab\npip install fps-login\n</code></pre> Now we launch Jupyverse at port <code>8001</code> and pass our own authentication token. In production, you would either create your own token, or let Jupyverse create it, and copy/paste it for server 2. <pre><code>jupyverse --port=8001 --set auth.token=5e9b01f993bc4fb48b2bf6958fd22981\n</code></pre> If you open your browser at <code>http://127.0.0.1:8000</code> (the URL of the Nginx reverse proxy), you should see the JupyterLab UI you're used to. But if you look closer, you can see that there is no icon for kernels in the launcher tab. And in the terminal where you launched Jupyverse, you will see a bunch of <code>404</code> for requests at e.g. <code>GET /api/kernels</code>. This is expected, because we didn't install the kernels plugin. You can still use JupyterLab if you don't want to execute a notebook, for instance. But let's close it for now, and install the kernels plugin in another Jupyverse instance.</p>"},{"location":"usage/microservices/#server-2-the-kernels-api","title":"Server 2: the kernels API","text":"<p>Let's create a new environment in a new terminal: <pre><code>micromamba create -n jupyverse2\nmicromamba activate jupyverse2\nmicromamba install -c conda-forge python\n</code></pre> This time, we only want to install the kernels plugin. Let's not forget to install a kernel, such as <code>ipykernel</code>: <pre><code>pip install fps-kernels\npip install fps-auth\npip install fps-frontend\npip install ipykernel\n</code></pre> Launch Juyverse at port <code>8002</code> with the same authentication token as for server 1: <pre><code>jupyverse --port=8002 --set auth.token=5e9b01f993bc4fb48b2bf6958fd22981\n</code></pre> Now if you re-open a browser at <code>http://127.0.0.1:8000</code>, you should be able to create or open a notebook, and execute it.</p>"},{"location":"usage/multi_user/","title":"Multi user","text":"<p>Jupyverse supports multiple users working collaboratively. Depending on the chosen authentication method, access to the server can be finer-grained. For instance, it is possible to require users to create an account before they can log in, and to give them permissions restricting access to specific resources. It is also possible to let them log in as anonymous users. The authentication method largely depends on the desired level of security.</p>"},{"location":"usage/multi_user/#collaborative-editing","title":"Collaborative editing","text":"<p>The first thing to do is to install the Jupyter collaboration package: <pre><code>pip install jupyter-collaboration\n</code></pre> Jupyverse must then be launched in collaborative mode: <pre><code>jupyverse --set frontend.collaborative=true\n</code></pre> The collaborative mode will handle users through the auth plugin you have installed, which will provide user identity.</p>"},{"location":"usage/multi_user/#identity-provider","title":"Identity provider","text":"<p>The real power of collaborative editing comes with proper user authentication and authorization. Jupyverse comes with several \"auth plugins\", that will be described below, but you can implement your own. It just has to follow a defined API.</p>"},{"location":"usage/multi_user/#using-fps-auth","title":"Using fps-auth","text":""},{"location":"usage/multi_user/#token-or-no-authentication","title":"Token or no authentication","text":"<p>It can be enabled by launching: <pre><code>jupyverse --set frontend.collaborative=true --set auth.mode=token\n</code></pre> This uses the token authentication, the same as described in the single user mode. This means that users don't get a \"real\" identity, since all they provide is the shared token. For this reason, we call them \"anonymous users\".</p> <p>They can still be differenciated, and they will each get assigned a different name e.g. in JupyterLab, but they will all have full access to any resource. For instance, they will be able to open all documents and to execute any code.</p> <p>You can also disable token authentication in collaborative mode, just as in single user mode: <pre><code>jupyverse --set frontend.collaborative=true --set auth.mode=noauth\n</code></pre></p>"},{"location":"usage/multi_user/#user-authentication","title":"User authentication","text":"<p>It can be enabled by launching: <pre><code>jupyverse --set frontend.collaborative=true --set auth.mode=user\n</code></pre> In this mode, users have to be registered in a database before logging in. User information includes a user name and a password, that will be asked at login. It can also include a \"real\" name, that will be displayed when editing documents, and permissions that will determine if they can see or edit a document, run some code, etc.</p>"},{"location":"usage/multi_user/#using-fps-auth-fief","title":"Using fps-auth-fief","text":"<p>fps-auth-fief uses Fief to authenticate users. Fief itself can be hosted in the cloud or locally, but in any case it runs a separate server, and implements OAuth2 to access Jupyverse.</p> <p>Fief allows to manage users using a dashboard. It supports permissions and Role-Based Access Control (RBAC).</p> <p>Just launch in a terminal: <pre><code>jupyverse --set frontend.collaborative=true\n</code></pre></p>"},{"location":"usage/single_user/","title":"Single user","text":"<p>The single user mode is usually meant to run e.g. JupyterLab as a desktop application. Under the hood, a server and a web frontend are launched, but it should be transparent to the user, who just interacts with a \"web app\".</p> <p>Even though Jupyverse most often runs on a personal computer in this mode, it is not limited to this use case. For instance, if it runs on a network, it could be accessed by other people. It is thus important to limit access to the server, especially considering that Jupyter users can run potentially harmful code.</p> <p>This is why Jupyverse comes with built-in authentication. Please refer to the auth plugins section for more details. The authentication mechanisms below make use of the fps-auth plugin.</p>"},{"location":"usage/single_user/#token-authentication","title":"Token authentication","text":"<p>This is the default mode when launching Jupyverse, just enter in a terminal: <pre><code>jupyverse --open-browser\n# same as: jupyverse --set auth.mode=token --open-browser\n</code></pre> This should open a new window in a browser, and load JupyterLab or RetroLab, depending on the front-end you chose to install (see Install).</p> <p>If you look at the terminal, you should see among other things: <pre><code>[2023-04-05 16:22:39,137 INFO] To access the server, copy and paste this URL:\n[2023-04-05 16:22:39,137 INFO] http://127.0.0.1:8000/?token=69ce8ccee10d4388b00b3df0d9849700\n</code></pre> This is the URL the browser window was opened with, and you can see that a <code>token</code> was passed as a query parameter. When the request is made to the server, the token is checked and a cookie is set in the browser. The user is now authenticated and doesn't need to pass the token again in other requests.</p> <p>Other users trying to access the server will be redirected to a login page. They can enter the token there, or completely bypass this step if they paste the above URL. Sharing the token is the responsibility of the user who launched Jupyverse. This simple mechanism effectively prevents access to the server by unkown users.</p>"},{"location":"usage/single_user/#no-authentication","title":"No authentication","text":"<p>If you trust everybody who can access the server, you can launch Jupyverse with no authentication whatsoever. It can also be convenient if you run Jupyverse on your personal computer and want to open e.g. JupyterLab in multiple browsers (e.g. Firefox and Google Chrome), since they don't share cookies. This way you won't need to pass any token in the URL.</p> <p>Enter in a terminal: <pre><code>jupyverse --set auth.mode=noauth --open-browser\n</code></pre></p>"}]}