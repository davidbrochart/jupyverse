{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Jupyverse is a modern Jupyter server. It can be used to run JupyterLab and other web clients: On your personal machine: that's the most common use case, where you want to do interactive computing, most often running notebooks, in your local environment. Although JupyterLab runs in the browser, it really feels like a desktop application. Collaboratively: users work on the same document in real time, connected to the same server. That means they are on the same private network (LAN), or the server is hosted on the Internet. The user experience is similar to Google Docs. With access control: this becomes necessary when working collaboratively, as you don't want everybody to be able to see or change anything. You want to know who users are and give them more or less permissions.","title":"Overview"},{"location":"install/","text":"Jupyverse can be installed to run either JupyterLab or RetroLab . With pip For the JupyterLab front-end: pip install \"jupyverse[jupyterlab]\" Or for the RetroLab front-end: pip install \"jupyverse[retrolab]\" With mamba For the JupyterLab front-end: mamba install -c conda-forge jupyverse fps-jupyterlab Or for the RetroLab front-end: mamba install -c conda-forge jupyverse fps-retrolab Note You cannot have both the JupyterLab and the RetroLab front-ends enabled at the same time. When switching e.g. from the JupyterLab to the RetroLab front-end, you need to pip uninstall fps-jupyterlab or launch Jupyverse with --JupyterLab.enabled=false . More on that in the plugins section . Development install You first need to clone the repository: git clone https://github.com/jupyter-server/jupyverse.git cd jupyverse Then install the needed plugins: pip install -e plugins/jupyterlab pip install -e plugins/login pip install -e plugins/auth pip install -e plugins/contents pip install -e plugins/kernels pip install -e plugins/terminals pip install -e plugins/lab pip install -e plugins/nbconvert pip install -e plugins/yjs pip install -e . [ test ] Note Same here, you cannot have both the JupyterLab and the RetroLab front-ends enabled at the same time. If you want RetroLab instead of JupyterLab, replace the first line with pip install -e plugins/retrolab .","title":"Install"},{"location":"install/#with-pip","text":"For the JupyterLab front-end: pip install \"jupyverse[jupyterlab]\" Or for the RetroLab front-end: pip install \"jupyverse[retrolab]\"","title":"With pip"},{"location":"install/#with-mamba","text":"For the JupyterLab front-end: mamba install -c conda-forge jupyverse fps-jupyterlab Or for the RetroLab front-end: mamba install -c conda-forge jupyverse fps-retrolab Note You cannot have both the JupyterLab and the RetroLab front-ends enabled at the same time. When switching e.g. from the JupyterLab to the RetroLab front-end, you need to pip uninstall fps-jupyterlab or launch Jupyverse with --JupyterLab.enabled=false . More on that in the plugins section .","title":"With mamba"},{"location":"install/#development-install","text":"You first need to clone the repository: git clone https://github.com/jupyter-server/jupyverse.git cd jupyverse Then install the needed plugins: pip install -e plugins/jupyterlab pip install -e plugins/login pip install -e plugins/auth pip install -e plugins/contents pip install -e plugins/kernels pip install -e plugins/terminals pip install -e plugins/lab pip install -e plugins/nbconvert pip install -e plugins/yjs pip install -e . [ test ] Note Same here, you cannot have both the JupyterLab and the RetroLab front-ends enabled at the same time. If you want RetroLab instead of JupyterLab, replace the first line with pip install -e plugins/retrolab .","title":"Development install"},{"location":"plugins/auth/","text":"The auth plugin has a special place because every other plugin depends on it for security reasons. It is possible to use any auth plugin as long as it follows a defined API. Jupyverse comes with two auth plugins: fps-auth and fps-auth-fief . API TODO fps-auth TODO fps-auth-fief TODO","title":"auth"},{"location":"plugins/auth/#api","text":"TODO","title":"API"},{"location":"plugins/auth/#fps-auth","text":"TODO","title":"fps-auth"},{"location":"plugins/auth/#fps-auth-fief","text":"TODO","title":"fps-auth-fief"},{"location":"plugins/contents/","text":"TODO","title":"fps-contents"},{"location":"plugins/fps/","text":"FPS is the system used in Jupyverse to extend its functionality. Actually, Jupyverse is just a collection of FPS plugins that implement a Jupyter server. Each plugin is quite independant, except that they all depend on the auth plugin. This is because almost every endpoint has to be protected one way or another.","title":"FPS"},{"location":"plugins/jupyterlab/","text":"TODO","title":"fps-jupyterlab"},{"location":"plugins/kernels/","text":"TODO","title":"fps-kernels"},{"location":"plugins/lab/","text":"TODO","title":"fps-lab"},{"location":"plugins/nbconvert/","text":"TODO","title":"fps-nbconvert"},{"location":"plugins/retrolab/","text":"TODO","title":"fps-retrolab"},{"location":"plugins/terminals/","text":"TODO","title":"fps-terminals"},{"location":"plugins/yjs/","text":"TODO","title":"fps-yjs"},{"location":"usage/multi_user/","text":"Jupyverse supports multiple users working collaboratively. Depending on the chosen authentication method, access to the server can be finer-grained. For instance, it is possible to require users to create an account before they can log in, and to give them permissions restricting access to specific resources. It is also possible to let them log in as anonymous users. The authentication method largely depends on the level of security you want. Collaborative editing The first thing to do is to allow collaborative editing when launching Jupyverse: jupyverse --lab.collaborative # same as: jupyverse --lab.collaborative --auth.mode=token This uses the default token authentication, the same as described in the single user mode . This means that users don't get a \"real\" identity, since all they provide is the shared token. For this reason, we call them \"anonymous users\". They can still be differenciated, and they will each get assigned a different name e.g. in JupyterLab, but they will all have full access to any resource. For instance, they will be able to open all documents and to execute any code. You can also disable token authentication in collaborative mode, just as in single user mode . Identity provider The real power of collaborative editing comes with proper user authentication and authorization. Jupyverse comes with several \"auth plugins\", that will be described below, but you can implement your own. It just has to follow a defined API. Using fps-auth fps-auth is the default authentication plugin. It adds endpoints to Jupyverse itself, and embeds the database. Thus, everything is self-contained. It can be enabled by launching: jupyverse --lab.collaborative --auth.mode = user In this mode, users have to be registered in a database before logging in. User information includes a user name and a password, that will be asked at login. It can also include a \"real\" name, that will be displayed when editing documents, and permissions that will determine if they can see or edit a document, run some code, etc. Using fps-auth-fief fps-auth-fief uses Fief to authenticate users. Fief itself can be hosted in the cloud or locally, but in any case it runs a separate server, and implements OAuth2 to access Jupyverse. Fief allows to manage users using a dashboard. It supports permissions and Role-Based Access Control (RBAC). Just launch in a terminal: jupyverse --lab.collaborative","title":"Multi user"},{"location":"usage/multi_user/#collaborative-editing","text":"The first thing to do is to allow collaborative editing when launching Jupyverse: jupyverse --lab.collaborative # same as: jupyverse --lab.collaborative --auth.mode=token This uses the default token authentication, the same as described in the single user mode . This means that users don't get a \"real\" identity, since all they provide is the shared token. For this reason, we call them \"anonymous users\". They can still be differenciated, and they will each get assigned a different name e.g. in JupyterLab, but they will all have full access to any resource. For instance, they will be able to open all documents and to execute any code. You can also disable token authentication in collaborative mode, just as in single user mode .","title":"Collaborative editing"},{"location":"usage/multi_user/#identity-provider","text":"The real power of collaborative editing comes with proper user authentication and authorization. Jupyverse comes with several \"auth plugins\", that will be described below, but you can implement your own. It just has to follow a defined API.","title":"Identity provider"},{"location":"usage/multi_user/#using-fps-auth","text":"fps-auth is the default authentication plugin. It adds endpoints to Jupyverse itself, and embeds the database. Thus, everything is self-contained. It can be enabled by launching: jupyverse --lab.collaborative --auth.mode = user In this mode, users have to be registered in a database before logging in. User information includes a user name and a password, that will be asked at login. It can also include a \"real\" name, that will be displayed when editing documents, and permissions that will determine if they can see or edit a document, run some code, etc.","title":"Using fps-auth"},{"location":"usage/multi_user/#using-fps-auth-fief","text":"fps-auth-fief uses Fief to authenticate users. Fief itself can be hosted in the cloud or locally, but in any case it runs a separate server, and implements OAuth2 to access Jupyverse. Fief allows to manage users using a dashboard. It supports permissions and Role-Based Access Control (RBAC). Just launch in a terminal: jupyverse --lab.collaborative","title":"Using fps-auth-fief"},{"location":"usage/single_user/","text":"The single user mode is usually meant to run e.g. JupyterLab as a desktop application. Under the hood, a server and a web front-end are launched, but it should be transparent to the user, who just interacts with a \"web app\". Even though Jupyverse most often runs on a personal computer in this mode, it is not limited to this use case. For instance, if it runs on a network, it could be accessed by other people. It is thus important to limit access to the server, especially considering that Jupyter users can run potentially harmful code. This is why Jupyverse comes with built-in authentication. Token authentication This is the default mode when launching Jupyverse, just enter in a terminal: jupyverse # same as: jupyverse --auth.mode=token This should open a new window in a browser, and load JupyterLab or RetroLab, depending on the front-end you chose to install (see Install ). If you look at the terminal, you should see among other things: [I 2022-08-30 09:37:55 auth] To access the server, copy and paste this URL: [I 2022-08-30 09:37:55 auth] http://127.0.0.1:8000/?token=59665677-06c6-4530-ab67-d26cd8865d8b This is the URL the browser window was opened with, and you can see that a token was passed as a query parameter. When the request is made to the server, the token is checked and a cookie is set in the browser. The user is now authenticated and doesn't need to pass the token again in other requests. Other users trying to access the server will be redirected to a login page. They can enter the token there, or completely bypass this step if they paste the above URL. Sharing the token is the responsibility of the user who launched Jupyverse. This simple mechanism effectively prevents access to the server by unkown users. No authentication If you trust everybody who can access the server, you can launch Jupyverse with no authentication whatsoever. It can also be convenient if you run Jupyverse on your personal computer and want to open e.g. JupyterLab in multiple browsers (e.g. Firefox and Google Chrome), since they don't share cookies. This way you won't need to pass any token in the URL. Enter in a terminal: jupyverse --auth.mode = noauth","title":"Single user"},{"location":"usage/single_user/#token-authentication","text":"This is the default mode when launching Jupyverse, just enter in a terminal: jupyverse # same as: jupyverse --auth.mode=token This should open a new window in a browser, and load JupyterLab or RetroLab, depending on the front-end you chose to install (see Install ). If you look at the terminal, you should see among other things: [I 2022-08-30 09:37:55 auth] To access the server, copy and paste this URL: [I 2022-08-30 09:37:55 auth] http://127.0.0.1:8000/?token=59665677-06c6-4530-ab67-d26cd8865d8b This is the URL the browser window was opened with, and you can see that a token was passed as a query parameter. When the request is made to the server, the token is checked and a cookie is set in the browser. The user is now authenticated and doesn't need to pass the token again in other requests. Other users trying to access the server will be redirected to a login page. They can enter the token there, or completely bypass this step if they paste the above URL. Sharing the token is the responsibility of the user who launched Jupyverse. This simple mechanism effectively prevents access to the server by unkown users.","title":"Token authentication"},{"location":"usage/single_user/#no-authentication","text":"If you trust everybody who can access the server, you can launch Jupyverse with no authentication whatsoever. It can also be convenient if you run Jupyverse on your personal computer and want to open e.g. JupyterLab in multiple browsers (e.g. Firefox and Google Chrome), since they don't share cookies. This way you won't need to pass any token in the URL. Enter in a terminal: jupyverse --auth.mode = noauth","title":"No authentication"}]}